/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.9 2005/01/07 09:37:18 dts12 Exp $
 */

#ifdef MAKE_SNMP

#include <eftos.h>
#include "basictyp.h"
#include "struct.h"
#include "sdk.h"
#include "fixdata.h"
#include "comdata.h"
#include "aqtab.h"
#include "hypffs.h"
#include "bci.h"
#include "hfs.h"
#include "hyputils.h"
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "fimpeOID.h"


#define S_T2100 5
const char cT2100[] = {"T2100"};
const char cM2100[] = {"M2100"};

#define S_PRESENT 7
const char cPRESENT[] = {"PRESENT"}; 
#define S_UNUSED 6
const char cUNUSED[] = {"UNUSED"}; 
#define S_UNKNOWN 3
const char cUNKNOWN[] = {"N/A"}; 

#define S_FLASHSIZE 7
const char cFLASHSIZE[] = {"4194304"}; 

#define S_V22 7
const char cV22[] = {"V.22bis"}; 
#define S_GSM 7
const char cGSM1[] = {"GSM hw1"}; 
const char cGSM2[] = {"GSM hw2"}; 
#define S_V90 4
const char cV90[] = {"V.90"}; 
#define S_ETHERNET 8
const char cETHERNET[] = {"Ethernet"}; 
#define S_BLUETOOTH 8
const char cBLUETOOTH[] = {"Bluetooth"}; 
#define S_ISDN 4
const char cISDN[] = {"ISDN"}; 
#define S_DIALBACKUP 9
const char cDIALBACKUP[] = {"GSM & V90"}; 
#define S_POSLAN 9
const char cPOSLAN[] = {"RS485 LAN"}; 
#define S_NO 2
const char cNO[] = {"NO"}; 

char cSerNum[256];

extern unsigned int HFS_PHYSICAL_PAGE_SIZE;
extern unsigned int HFS_OS_RESV_SIZE;
extern Bool Battery_available;

/** Initializes the fimpeOID module */
void
init_fimpeOID(void)
{
    static oid      sysMrchntinfoBlk_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 1 };
    static oid      sysMdlNum_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 2 };
    static oid      sysPartNum_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 3 };
    static oid      sysHwVer_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 4 };
    static oid      sysSrlNum_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 5 };
    static oid      sysPtidNum_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 6 };
    static oid      sysMdmModId_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 7 };
    static oid      sysPinPadInfo_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 8 };
    static oid      sysPRNInfo_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 9 };
    static oid      sysOsVer_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 10 };
    static oid      sysMfgLotNum_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 11 };
    static oid      sysRamSz_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 12 };
    static oid      sysFlashSz_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 13 };
    static oid      sysTime_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 14 };
    static oid      sysDate_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 15 };
    static oid      sysFreeRam_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 16 };
    static oid      sysFreeFlash_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 17 };
    static oid      sysBatStat_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 1, 1, 18 };
    static oid      fimpeTotalTransactions_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 2, 2, 1 };
    static oid      fimpeOnLineSales_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 2, 2, 2 };
    static oid      fimpeOffLineSales_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 2, 2, 3 };
    static oid      fimpeRefundTransactions_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 2, 2, 4 };
    static oid      fimpePreauthTransactions_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 2, 2, 5 };
    static oid      fimpeAdjustSaleTransactions_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 2, 2, 6 };
    static oid      fimpeManualEntries_oid[] =
        { 1, 3, 6, 1, 4, 1, 626, 123, 2, 2, 7 };

    DEBUGMSGTL(("fimpeOID", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysMrchntinfoBlk", handle_sysMrchntinfoBlk,
                             sysMrchntinfoBlk_oid,
                             OID_LENGTH(sysMrchntinfoBlk_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysMdlNum", handle_sysMdlNum, sysMdlNum_oid,
                             OID_LENGTH(sysMdlNum_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysPartNum", handle_sysPartNum,
                             sysPartNum_oid, OID_LENGTH(sysPartNum_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysHwVer", handle_sysHwVer, sysHwVer_oid,
                             OID_LENGTH(sysHwVer_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysSrlNum", handle_sysSrlNum, sysSrlNum_oid,
                             OID_LENGTH(sysSrlNum_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysPtidNum", handle_sysPtidNum,
                             sysPtidNum_oid, OID_LENGTH(sysPtidNum_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysMdmModId", handle_sysMdmModId,
                             sysMdmModId_oid, OID_LENGTH(sysMdmModId_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysPinPadInfo", handle_sysPinPadInfo,
                             sysPinPadInfo_oid,
                             OID_LENGTH(sysPinPadInfo_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysPRNInfo", handle_sysPRNInfo,
                             sysPRNInfo_oid, OID_LENGTH(sysPRNInfo_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysOsVer", handle_sysOsVer, sysOsVer_oid,
                             OID_LENGTH(sysOsVer_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysMfgLotNum", handle_sysMfgLotNum,
                             sysMfgLotNum_oid,
                             OID_LENGTH(sysMfgLotNum_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysRamSz", handle_sysRamSz, sysRamSz_oid,
                             OID_LENGTH(sysRamSz_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysFlashSz", handle_sysFlashSz,
                             sysFlashSz_oid, OID_LENGTH(sysFlashSz_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysTime", handle_sysTime, sysTime_oid,
                             OID_LENGTH(sysTime_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysDate", handle_sysDate, sysDate_oid,
                             OID_LENGTH(sysDate_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysFreeRam", handle_sysFreeRam,
                             sysFreeRam_oid, OID_LENGTH(sysFreeRam_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysFreeFlash", handle_sysFreeFlash,
                             sysFreeFlash_oid,
                             OID_LENGTH(sysFreeFlash_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("sysBatStat", handle_sysBatStat,
                             sysBatStat_oid, OID_LENGTH(sysBatStat_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("fimpeTotalTransactions",
                             handle_fimpeTotalTransactions,
                             fimpeTotalTransactions_oid,
                             OID_LENGTH(fimpeTotalTransactions_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("fimpeOnLineSales", handle_fimpeOnLineSales,
                             fimpeOnLineSales_oid,
                             OID_LENGTH(fimpeOnLineSales_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("fimpeOffLineSales", handle_fimpeOffLineSales,
                             fimpeOffLineSales_oid,
                             OID_LENGTH(fimpeOffLineSales_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("fimpeRefundTransactions",
                             handle_fimpeRefundTransactions,
                             fimpeRefundTransactions_oid,
                             OID_LENGTH(fimpeRefundTransactions_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("fimpePreauthTransactions",
                             handle_fimpePreauthTransactions,
                             fimpePreauthTransactions_oid,
                             OID_LENGTH(fimpePreauthTransactions_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("fimpeAdjustSaleTransactions",
                             handle_fimpeAdjustSaleTransactions,
                             fimpeAdjustSaleTransactions_oid,
                             OID_LENGTH(fimpeAdjustSaleTransactions_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("fimpeManualEntries",
                             handle_fimpeManualEntries,
                             fimpeManualEntries_oid,
                             OID_LENGTH(fimpeManualEntries_oid),
                             HANDLER_CAN_RONLY));
}

int
handle_sysMrchntinfoBlk(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	struct acquirer_rec * pAcquirer;

    switch (reqinfo->mode) {

    case MODE_GET:

		pAcquirer = FindFirstAcquirer();

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 pAcquirer->AQACCID
                                 ,
                                 S_AQACCID);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysMrchntinfoBlk\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysMdlNum(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	char * pType;

    switch (reqinfo->mode) {

    case MODE_GET:
		
		if ( HARDWARE_TYPE_DETECT == HARDWARE_T2100 )
			pType = (char *) cT2100;
		else
			pType = (char *) cM2100;

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 pType, S_T2100);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysMdlNum\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysPartNum(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 cUNKNOWN,
                                 S_UNKNOWN);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysPartNum\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysHwVer(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 cUNKNOWN,
                                 S_UNKNOWN);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysHwVer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysSrlNum(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 cSerNum,
                                 strlen(cSerNum));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysSrlNum\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysPtidNum(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 TERM.TERMSer,
                                 8);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysPtidNum\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysMdmModId(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	char * pModule;
	char lenght;

    switch (reqinfo->mode) {

    case MODE_GET:


		switch(TERM.TERMOpt3 & TM3_HWTYPE_MASK)
		{
			case TM3_GSM:
				pModule = (char *)cGSM2;
				lenght = S_GSM;
				break;

			case TM3_GSM_OLD:
				pModule = (char *)cGSM1;
				lenght = S_GSM;
				break;

			case TM3_V90:
				pModule = (char *)cV90;
				lenght = S_V90;
				break;

			case TM3_V22:
				pModule = (char *)cV22;
				lenght = S_V22;
				break;

			case TM3_ETHERNET:
				pModule = (char *)cETHERNET;
				lenght = S_ETHERNET;
				break;

			case TM3_BLUETOOTH:
				pModule = (char *)cBLUETOOTH;
				lenght = S_BLUETOOTH;
				break;

			case TM3_LAN:
				pModule = (char *)cPOSLAN;
				lenght = S_POSLAN;
				break;

			case TM3_ISDN:
				pModule = (char *)cISDN;
				lenght = S_ISDN;
				break;

			case TM3_DIALBACKUP: 
				pModule = (char *)cDIALBACKUP;
				lenght = S_DIALBACKUP;
				break;

			default:
				pModule = (char *)cNO;
				lenght = S_NO;
				break;
	}

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 pModule,
                                 lenght);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysMdmModId\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysPinPadInfo(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */


	char * pType;
	char   lenght;
		
    switch (reqinfo->mode) {

    case MODE_GET:
		if (TCONF.TCOPT6 & TC6_PININTERNAL)
		{
			pType = (char *) cPRESENT;
			lenght = S_PRESENT;
		}
		else
		{
			pType = (char *) cUNUSED;
			lenght = S_UNUSED;
		}
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 pType,
                                 lenght);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysPinPadInfo\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysPRNInfo(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	char * pType;
	char   lenght;

    switch (reqinfo->mode) {
    case MODE_GET:
		if ( TCONF.TCOPT2 & TC2_PRINT )
		{
			pType = (char *) cPRESENT;
			lenght = S_PRESENT;
		}
		else
		{
			pType = (char *) cUNUSED;
			lenght = S_UNUSED;
		}

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 pType,
                                 lenght);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysPRNInfo\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysOsVer(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	char temp_string[256];
	VERSION_INFO sdkversion;

    switch (reqinfo->mode) {

    case MODE_GET:

	SDK_Version( &sdkversion );
	strcpy( temp_string, sdkversion.OSrelease );
	strcat( temp_string , " " );
	strcat( temp_string , sdkversion.OSversion );

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 temp_string
                                 ,
                                 strlen(temp_string));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysOsVer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysMfgLotNum(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 cUNKNOWN,
                                 S_UNKNOWN);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysMfgLotNum\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysRamSz(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	long lRAMSize;
	char temp_string[256] = {0};
    switch (reqinfo->mode) {

    case MODE_GET:
		lRAMSize = HFS_PHYSICAL_PAGE_SIZE - HFS_OS_RESV_SIZE;
		itoa (lRAMSize, temp_string, 10);
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 temp_string,
                                 strlen(temp_string));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysRamSz\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysFlashSz(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 cFLASHSIZE
                                 ,S_FLASHSIZE);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysFlashSz\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysTime(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	char temp_string[5];
	char time_data[21];

    switch (reqinfo->mode) {

    case MODE_GET:
		SDK_RtcRead( ( UBYTE * ) time_data );
		temp_string[0] = time_data[6];
		temp_string[1] = time_data[7];
		temp_string[2] = ':';
		temp_string[3] = time_data[8];
		temp_string[4] = time_data[9];
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 temp_string,
                                 5);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysTime\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysDate(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

	char temp_string[8];
	char time_data[21];

    switch (reqinfo->mode) {
    case MODE_GET:
		SDK_RtcRead( ( UBYTE * ) time_data );
		temp_string[0] = time_data[4];
		temp_string[1] = time_data[5];
		temp_string[2] = '.';
		temp_string[3] = time_data[2];
		temp_string[4] = time_data[3];
		temp_string[5] = '.';
		temp_string[6] = time_data[0];
		temp_string[7] = time_data[1];
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 temp_string, 8);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysDate\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysFreeRam(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	long lSpace;
	char temp_string[256]= {0} ;
    switch (reqinfo->mode) {

    case MODE_GET:
		lSpace = fspaceavail();
		itoa(lSpace, temp_string, 10);
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 temp_string,
                                 strlen(temp_string));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysFreeRam\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysFreeFlash(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	long lSpace;
	char temp_string[256]= {0} ;

    switch (reqinfo->mode) {

    case MODE_GET:
		lSpace = FFS_GetFreeSpace();
		itoa(lSpace, temp_string, 10);
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 temp_string,
                                 strlen(temp_string));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysFreeFlash\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sysBatStat(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	char temp_string;
    switch (reqinfo->mode) {

    case MODE_GET:
		if (Battery_available)
		{
			if ( ( BCI_Capacity ( ) >= 3) || (BCI_BatteryCharge()))
				temp_string = '1';
			else
				temp_string = '0';
		}
		else
		{
			temp_string = '1';
		}
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,                                 
                                 &temp_string,
                                 1);
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sysBatStat\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_fimpeTotalTransactions(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)
                                 &MIBTRANSTAB.mibTotalTrans
                                 ,
                                 sizeof(MIBTRANSTAB.mibTotalTrans));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_fimpeTotalTransactions\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_fimpeOnLineSales(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)
                                 &MIBTRANSTAB.mibTotalOnlineSale
                                 ,
                                 sizeof(MIBTRANSTAB.mibTotalOnlineSale));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_fimpeOnLineSales\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_fimpeOffLineSales(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)
                                 &MIBTRANSTAB.mibTotalOfflineSale
                                 ,
                                 sizeof(MIBTRANSTAB.mibTotalOfflineSale));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_fimpeOffLineSales\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_fimpeRefundTransactions(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)
                                 &MIBTRANSTAB.mibTotalRefund
                                 ,
                                 sizeof(MIBTRANSTAB.mibTotalRefund));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_fimpeRefundTransactions\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_fimpePreauthTransactions(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)
                                 &MIBTRANSTAB.mibTotalAuth
                                 ,
                                 sizeof(MIBTRANSTAB.mibTotalAuth));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_fimpePreauthTransactions\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_fimpeAdjustSaleTransactions(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)
                                 &MIBTRANSTAB.mibTotalAdjSale
                                 ,
                                 sizeof(MIBTRANSTAB.mibTotalAdjSale));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_fimpeAdjustSaleTransactions\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_fimpeManualEntries(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                 (u_char *)
                                 &MIBTRANSTAB.mibManualEntrys
                                 ,
                                 sizeof(MIBTRANSTAB.mibManualEntrys));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_fimpeManualEntries\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#endif // MAKE_SNMP

